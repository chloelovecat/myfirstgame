<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>小貓貓養成記 — 貪吃蛇</title>
  <style>
    :root{--bg:#f6f7fb;--grid:#e1e6f0;--cat:#ffb6c1;--fish:#8ad1ff;--rock:#c2c2c2;}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Noto Sans TC',Helvetica,Arial; background:var(--bg); color:#222}
    .wrap{display:flex;gap:24px;padding:24px;align-items:flex-start}
    #game{background:linear-gradient(180deg,#fff,#f3f6ff);border-radius:12px;box-shadow:0 6px 20px rgba(20,30,80,0.08);padding:12px}
    canvas{display:block;background:transparent;border-radius:8px}
    .ui{min-width:220px}
    .panel{background:#fff;padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(20,30,80,0.06)}
    h1{margin:0 0 8px;font-size:18px}
    .muted{color:#667; font-size:13px}
    .bigscore{font-size:28px;margin:8px 0 0}
    .btn{display:inline-block;padding:8px 12px;border-radius:8px;border:none;background:#3b82f6;color:#fff;cursor:pointer}
    .overlay{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center}
    .overlay .card{background:rgba(255,255,255,0.98);padding:18px;border-radius:10px;box-shadow:0 6px 30px rgba(0,0,0,0.15);text-align:center}
    footer{margin-top:8px;font-size:12px;color:#556}
    @media (max-width:720px){.wrap{flex-direction:column;align-items:center}.ui{width:100%;max-width:420px}}
  </style>
</head>
<body>
  <div class="wrap">
    <div id="game" style="position:relative">
      <canvas id="c" width="600" height="600"></canvas>
      <div id="overlay" class="overlay" style="display:none">
        <div class="card">
          <h2 id="ov-title">遊戲結束</h2>
          <div style="font-size:20px;margin:8px 0">你的分數：<strong id="ov-score">0</strong></div>
          <button id="restartBtn" class="btn">重新開始</button>
        </div>
      </div>
    </div>

    <div class="ui">
      <div class="panel">
        <h1>小貓貓養成記</h1>
        <div class="muted">控制：方向鍵 / WASD</div>
        <div style="margin-top:12px">當小貓吃到小魚會變長；吃到魚罐頭長度加倍；撞到石頭會變短；碰到邊界遊戲結束。</div>
        <div style="margin-top:12px">
          <div class="muted">目前分數</div>
          <div class="bigscore" id="score">0</div>
        </div>
        <div style="margin-top:12px">
          <button id="pauseBtn" class="btn">暫停</button>
          <button id="stepBtn" class="btn" style="background:#10b981;margin-left:8px">快照一步</button>
        </div>
        <footer>魚每 2s 出現；石頭每 3s 出現；魚罐頭每 7s 出現。</footer>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const ovScore = document.getElementById('ov-score');
    const scoreEl = document.getElementById('score');
    const pauseBtn = document.getElementById('pauseBtn');
    const stepBtn = document.getElementById('stepBtn');
    const restartBtn = document.getElementById('restartBtn');

    const canvasSize = 600;
    const gridCount = 20;
    const cell = canvasSize / gridCount;

    const fishIntervalMs = 2000;
    const rockIntervalMs = 3000;
    const canIntervalMs = 7000;

    let snake = [];
    let dir = {x:1,y:0};
    let nextDir = {x:1,y:0};
    let fishes = [];
    let rocks = [];
    let cans = [];
    let score = 0;
    let gameOver = false;
    let paused = false;
    let timer = null;
    let fishTimer = null;
    let rockTimer = null;
    let canTimer = null;
    let stepOnce = false;

    function reset(){
      snake = [];
      const mid = Math.floor(gridCount/2);
      snake.push({x:mid-1,y:mid});
      snake.push({x:mid,y:mid});
      snake.push({x:mid+1,y:mid});
      dir = {x:1,y:0};
      nextDir = {x:1,y:0};
      fishes = [];
      rocks = [];
      cans = [];
      score = 0;
      gameOver = false;
      paused = false;
      updateScore();
      overlay.style.display = 'none';
      if(fishTimer) clearInterval(fishTimer);
      if(rockTimer) clearInterval(rockTimer);
      if(canTimer) clearInterval(canTimer);
      fishTimer = setInterval(spawnFish, fishIntervalMs);
      rockTimer = setInterval(spawnRock, rockIntervalMs);
      canTimer = setInterval(spawnCan, canIntervalMs);
      if(timer) cancelAnimationFrame(timer);
      stepOnce = false;
      loop();
    }

    function rndInt(max){ return Math.floor(Math.random()*max); }
    function posToPixel(p){ return {px: p.x*cell, py: p.y*cell}; }

    function spawnFish(){
      const pos = getFreeCell();
      if(pos) fishes.push({x:pos.x,y:pos.y,id:Date.now()});
    }

    function spawnRock(){
      const pos = getFreeCell();
      if(pos) rocks.push({x:pos.x,y:pos.y,id:Date.now()});
    }

    function spawnCan(){
      const pos = getFreeCell();
      if(pos) cans.push({x:pos.x,y:pos.y,id:Date.now()});
    }

    function getFreeCell(){
      const available = [];
      for(let x=0;x<gridCount;x++){
        for(let y=0;y<gridCount;y++){
          if(!occupied(x,y)) available.push({x,y});
        }
      }
      if(available.length===0) return null;
      return available[rndInt(available.length)];
    }

    function occupied(x,y){
      for(const s of snake) if(s.x===x && s.y===y) return true;
      for(const f of fishes) if(f.x===x && f.y===y) return true;
      for(const r of rocks) if(r.x===x && r.y===y) return true;
      for(const c of cans) if(c.x===x && c.y===y) return true;
      return false;
    }

    function updateScore(){ scoreEl.textContent = score; }

    function drawGrid(){
      ctx.clearRect(0,0,canvasSize,canvasSize);
      ctx.fillStyle = '#fff';
      ctx.fillRect(0,0,canvasSize,canvasSize);
      ctx.strokeStyle = '#eef3fb';
      ctx.lineWidth = 1;
      for(let i=0;i<=gridCount;i++){
        const p = i*cell;
        ctx.beginPath(); ctx.moveTo(p,0); ctx.lineTo(p,canvasSize); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0,p); ctx.lineTo(canvasSize,p); ctx.stroke();
      }
    }

    function drawSnake(){
      for(let i=0;i<snake.length;i++){
        const s = snake[i];
        const {px,py} = posToPixel(s);
        if(i===snake.length-1){
          ctx.fillStyle = '#ff9fb8';
          roundRect(ctx,px+2,py+2,cell-4,cell-4,6,true,false);
          ctx.font = Math.floor(cell*0.6)+'px serif';
          ctx.textAlign='center'; ctx.textBaseline='middle';
          ctx.fillStyle='#6b2b2b';
          ctx.fillText('🐱', px+cell/2, py+cell/2+1);
        } else {
          ctx.fillStyle = '#ffc7d2';
          roundRect(ctx,px+2,py+2,cell-4,cell-4,6,true,false);
        }
      }
    }

    function drawFishes(){
      ctx.font = Math.floor(cell*0.7)+'px serif';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      for(const f of fishes){
        const {px,py} = posToPixel(f);
        ctx.fillText('🐟', px+cell/2, py+cell/2+1);
      }
    }
    function drawRocks(){
      ctx.font = Math.floor(cell*0.6)+'px serif';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      for(const r of rocks){
        const {px,py} = posToPixel(r);
        ctx.fillText('🪨', px+cell/2, py+cell/2+1);
      }
    }
    function drawCans(){
      ctx.font = Math.floor(cell*0.6)+'px serif';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      for(const c of cans){
        const {px,py} = posToPixel(c);
        ctx.fillText('🥫', px+cell/2, py+cell/2+1);
      }
    }

    function roundRect(ctx,x,y,w,h,r,fill,stroke){
      if(typeof r==='undefined') r=5;
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      if(fill) ctx.fill();
      if(stroke) ctx.stroke();
    }

    function step(){
      if(gameOver) return;
      if(paused && !stepOnce) return;
      stepOnce = false;
      if((nextDir.x!==-dir.x || nextDir.y!==-dir.y) ) dir = nextDir;
      const head = {...snake[snake.length-1]};
      head.x += dir.x; head.y += dir.y;
      if(head.x < 0 || head.x >= gridCount || head.y < 0 || head.y >= gridCount){
        endGame(); return;
      }
      snake.push(head);

      let ateFish = false;
      for(let i=0;i<fishes.length;i++){
        const f = fishes[i];
        if(f.x===head.x && f.y===head.y){
          ateFish = true;
          fishes.splice(i,1);
          score += 1;
          updateScore();
          break;
        }
      }
      if(!ateFish){
        snake.shift();
      }

      for(let i=0;i<cans.length;i++){
        const c = cans[i];
        if(c.x===head.x && c.y===head.y){
          cans.splice(i,1);
          score += 3;
          updateScore();
          // double length: duplicate current body
          const extra = snake.slice(0);
          snake = extra.concat(snake);
          break;
        }
      }

      for(let i=0;i<rocks.length;i++){
        const r = rocks[i];
        if(r.x===head.x && r.y===head.y){
          const removeCount = Math.min(2, Math.max(1, snake.length-1));
          for(let k=0;k<removeCount;k++){
            snake.shift();
          }
          rocks.splice(i,1);
          break;
        }
      }
    }

    function loop(){
      drawGrid();
      drawFishes();
      drawRocks();
      drawCans();
      drawSnake();
      if(!gameOver){
        timer = requestAnimationFrame(loop);
      }
    }

    const moveIntervalMs = 140;
    let moveInterval = setInterval(()=>{ if(!gameOver && !paused) { step(); } }, moveIntervalMs);

    function endGame(){
      gameOver = true;
      ovScore.textContent = score;
      overlay.style.display = 'flex';
    }

    window.addEventListener('keydown', (e)=>{
      const key = e.key;
      if(['ArrowUp','w','W','ArrowDown','ArrowLeft','ArrowRight','a','A','s','S','d','D'].includes(key)){
        e.preventDefault();
      }
      if(key==='ArrowUp' || key==='w' || key==='W') nextDir = {x:0,y:-1};
      if(key==='ArrowDown' || key==='s' || key==='S') nextDir = {x:0,y:1};
      if(key==='ArrowLeft' || key==='a' || key==='A') nextDir = {x:-1,y:0};
      if(key==='ArrowRight' || key==='d' || key==='D') nextDir = {x:1,y:0};
      if(key===' '){ paused = !paused; pauseBtn.textContent = paused? '繼續' : '暫停'; }
    });

    pauseBtn.addEventListener('click', ()=>{ paused = !paused; pauseBtn.textContent = paused? '繼續' : '暫停'; });
    stepBtn.addEventListener('click', ()=>{ if(!gameOver){ stepOnce = true; step(); } });
    restartBtn.addEventListener('click', ()=>{ reset(); });

    spawnFish(); spawnRock(); spawnCan();
    fishTimer = setInterval(spawnFish, fishIntervalMs);
    rockTimer = setInterval(spawnRock, rockIntervalMs);
    canTimer = setInterval(spawnCan, canIntervalMs);

    reset();

    function resizeCanvas(){
      const dpr = window.devicePixelRatio || 1;
      canvas.width = canvasSize * dpr;
      canvas.height = canvasSize * dpr;
      canvas.style.width = canvasSize + 'px';
      canvas.style.height = canvasSize + 'px';
      ctx.setTransform(dpr,0,0,dpr,0,0);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

  </script>
</body>
</html>